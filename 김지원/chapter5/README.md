# chapter05. 트랜잭션과 잠금

- 잠금(Lock): 여러 커넥션이 동시에 동일 자원을 요청할 경우, 순서대로 한 시점에 하나의 커넥션만 변결 할 수 있게 하는 역할(동시성 제어)
- 트랜잭션: 논리적인 작업 셋이 100% 적용되거나(Commit), 아무것도 적용되지 않아야(Rollback) 함을 보장 해주는 역할(데이터의 정합성)
- 격리수준: 하나의 트랜잭션 내에서 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨

## 트랜잭션

- InnoDB 스토리지 엔진에서만 트랜잭션을 지원한다.
- MyISAM, MEMORY 스토리지 엔진에서는 트랜잭션을 지원하지 않아, 부분 업데이트(Partial Update) 현상 발생
- 프로그램 코드가 가지고 있는 커넥션의 범위 및 트랜잭션의 범위를 최소화해야 한다.

## MySQL 엔진의 잠금

### 글로벌 락

- 명령어: FLUSH TABLES WITH READ LOCK
- 한 세션이 글로벌락을 획득하면, 다른 세션에서 SELECT 를 제외한 모든 DDL, DML을 실행할 경우 대기해야한다.
- MySQL 서버 전체 영향
- 백업을 위한 목적으로 사용
- InnoDB: 테이블의 데이터 변경은 허용하는 글로벌 락 도입

### 테이블 락

- 명령어: 잠금(LOCK TABLES table_name \[READ | WRITE\]), 해제(UNLOCK TABLES table_name)
- 개별 테이블 단위로 설정되는 잠금
- 묵지적 테이블 락
    - MyISAM, MEMORY: 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
    - InnoDB: 레코드 기반의 잠금을 제공하므로, 테이블 락이 발생하지 않는다.

### 네임드 락

- 사용자가 지정한 문자열(String)에 대하여 락을 획득하고 반납
- 어떤 정보에 대하여 여러 클라이언트가 상호 동기화를 처리해야 할때 이용
    - 주문 도메인에서 여러 클라이언트가 상품의 재고 수량 데이터에 접근 하려고 할 때...

### 메타데이터 락

- 데이터 베이스 객체(테이블, 뷰)의 이름이나 구조를 변경 하는 경우에 획득하는 잠금

## InnoDB 스토리지 엔진 잠금

- 스토리지 엔진에서 레코드 기반의 잠금 방식을 제공
- 트랜잭션의 잠금, 잠금 대기 중인 트랜잭션의 조회 목록을 조회 가능

### 레코드 락

- 레코드 자체가 아닌 인덱스(클러스터 인덱스)의 레코드를 잠근다.
- 보조 인덱스를 이용한 변경: 넥스트 키 락, 갭 락 사용

### 갭 락

- 레코드와 바로 인접한 레코드 사이의 간격만을 잠근다.
- 레코드와 레코드 사이에 새로운 레코드가 생성 되는 것을 제어

### 넥스트 키 락

- 레코드 락 + 갭 락
- 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어 내도록 보장(STATEMENT 포맷)
    - 데드락 발생 위험, 다른 트랜잭션 대기로 인한 성능 저하 -> ROW 형태의 바이너리 로그를 사용하자.

> 바이너리 로그의 STATEMENT 포맷 <br>
> SQL 쿼리문을 기록하는 형식, 데이터베이스에 적용된 작업의 순서대로 기록

> 바이너리 로그의 ROW 포맷 <br>
> 데이터의 변경 내용을 레코드 단위로 기록하는 형식

### 자동 증가 락

- AUTO_INCREMENT 락, 테이블 수준의 잠금
- AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제

### 인덱스와 잠금

- 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.
- 테이블에 인덱스가 없다면, 테이블 풀스캔하면서 모든 레코드에 락을 걸게 된다.

### 레코드 수준의 잠금 확인 및 해제

- 각 트랜잭션이 어떤 잠금을 기다리고 있는지, 기다리고 있는 잠금을 어떤 트랜잭션이 가지고 있는지를 메타 정보를 통해 조회 가능

## MySQL의 격리 수준

- 여러 트랜잭션이 동시에 처리될때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수있게 허용 할지 말지를 결정하는 것
- 고립 정도와 동시 처리 능력이 반비례

### READ UNCOMMITTED

- 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 더티 리드 현상이 나타난다.

### READ COMMITTED

- 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에 조회 가능
- 동일 트랜잭션 내에서 다른 조회 결과를 만들어내는 NON-REPEATABLE READ 발생

### REPEATABLE READ

> Note <br>
> 모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지고 있다. <br>
> 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 변호가 포함되어 있다.

- 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서 동일한 결과를 보여줄수 있게 보장한다.
- 실행중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터를 삭제 할 수 없다.
- `SELECT ... FOR UPDATE`: Select하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸수 없으므로, 언두 영역의 변경전 데이터가 아닌 현재 레코드의 값을 가져오게 온다.(팬텀 리드 발생 가능)

### SERIALIZABLE 
- 읽기 작업도 공유 잠금(읽기 잠금)을 획득
- 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대로 접근 할 수 없다.

